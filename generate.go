package command

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

func GeneratePackageFunctions(pkgDir, genFilename string, onlyFuncs ...string) error {
	pkgName, funcs, err := parsePackage(pkgDir, genFilename, onlyFuncs...)
	if err != nil {
		return err
	}

	importLines := map[string]bool{
		`"reflect"`: true,
		`command "github.com/ungerik/go-command"`: true,
	}
	for fun, file := range funcs {
		err = GetFunctionImports(importLines, file, fun)
		if err != nil {
			return err
		}
	}
	var sortedImportLines []string
	for l := range importLines {
		sortedImportLines = append(sortedImportLines, l)
	}
	sort.Strings(sortedImportLines)

	b := bytes.NewBuffer(nil)

	fmt.Fprintf(b, "// This file has been AUTOGENERATED!\n\n")
	fmt.Fprintf(b, "package %s\n\n", pkgName)
	if len(sortedImportLines) > 0 {
		fmt.Fprintf(b, "import (\n")
		for _, importLine := range sortedImportLines {
			fmt.Fprintf(b, "\t%s\n", importLine)
		}
		fmt.Fprintf(b, ")\n\n")
	}

	for fun, file := range funcs {
		err = WriteFunctionImpl(b, file, fun, "Func"+fun.Name.Name)
		if err != nil {
			return err
		}
	}

	getFileData := b.Bytes()
	genFilePath := filepath.Join(pkgDir, genFilename)

	fmt.Println("Writing file", genFilePath)

	imports.LocalPrefix = "github.com/ungerik/"
	getFileData, err = imports.Process(genFilePath, getFileData, &imports.Options{Comments: true, FormatOnly: true})
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(genFilePath, getFileData, 0660)
	if err != nil {
		return err
	}
	// err = exec.Command("gofmt", "-s", "-w", genFile).Run()
	// if err != nil {
	// 	return err
	// }

	return nil
}

func parsePackage2(pkgDir, genFilename string, onlyFuncs ...string) (pkgName string, funcs map[*ast.FuncDecl]*ast.File, err error) {
	config := &packages.Config{
		Mode: packages.NeedName + packages.NeedImports + packages.NeedTypes + packages.NeedSyntax + packages.NeedTypesInfo,
		Dir:  pkgDir,
	}
	pkgs, err := packages.Load(config, pkgDir)
	if err != nil {
		return "", nil, err
	}
	if err != nil {
		return "", nil, err
	}
	if len(pkgs) != 1 {
		return "", nil, fmt.Errorf("%d packages found in %s", len(pkgs), pkgDir)
	}
	pkgName = pkgs[0].Name
	files := pkgs[0].Syntax

	funcs = make(map[*ast.FuncDecl]*ast.File)
	for _, file := range files {
		// ast.Print(fileSet, file.Imports)
		for _, obj := range file.Scope.Objects {
			if obj.Kind != ast.Fun {
				// ast.Print(fileSet, obj)
				continue
			}
			funcDecl := obj.Decl.(*ast.FuncDecl)
			if len(onlyFuncs) > 0 {
				for _, name := range onlyFuncs {
					if funcDecl.Name.Name == name {
						funcs[funcDecl] = file
						break
					}
				}
			} else if funcDecl.Name.IsExported() {
				funcs[funcDecl] = file
			}
		}
	}
	return pkgName, funcs, nil

}

func parsePackage(pkgDir, genFilename string, onlyFuncs ...string) (pkgName string, funcs map[*ast.FuncDecl]*ast.File, err error) {
	fileSet := token.NewFileSet()
	pkgs, err := parser.ParseDir(fileSet, pkgDir, filterGoFiles(genFilename), 0)
	if err != nil {
		return "", nil, err
	}
	if len(pkgs) != 1 {
		return "", nil, fmt.Errorf("%d packages found in %s", len(pkgs), pkgDir)
	}
	var files []*ast.File
	for _, p := range pkgs {
		pkgName = p.Name
		for _, file := range p.Files {
			files = append(files, file)
		}
	}

	// // typesInfo.Uses allows to lookup import paths for identifiers.
	// typesInfo := &types.Info{Uses: make(map[*ast.Ident]types.Object)}
	// // Type check the parsed code using the default importer.
	// // Use golang.org/x/tools/go/loader to check a program
	// // consisting of multiple packages.
	// conf := types.Config{Importer: importer.Default()}
	// _, err = conf.Check(pkgDir, fileSet, files, typesInfo)
	// if err != nil {
	// 	return nil, err
	// }

	funcs = make(map[*ast.FuncDecl]*ast.File)
	for _, file := range files {
		// ast.Print(fileSet, file.Imports)
		for _, obj := range file.Scope.Objects {
			if obj.Kind != ast.Fun {
				// ast.Print(fileSet, obj)
				continue
			}
			funcDecl := obj.Decl.(*ast.FuncDecl)
			if len(onlyFuncs) > 0 {
				for _, name := range onlyFuncs {
					if funcDecl.Name.Name == name {
						funcs[funcDecl] = file
						break
					}
				}
			} else if funcDecl.Name.IsExported() {
				funcs[funcDecl] = file
			}
		}
	}
	return pkgName, funcs, nil
}

func GetFunctionImpl(file *ast.File, funcDecl *ast.FuncDecl, implType string) (implSource string, err error) {
	b := new(strings.Builder)
	err = WriteFunctionImpl(b, file, funcDecl, implType)
	if err != nil {
		return "", err
	}
	return b.String(), nil
}

func WriteFunctionImpl(w io.Writer, file *ast.File, funcDecl *ast.FuncDecl, implType string) error {
	argNames := funcDeclArgNames(funcDecl)
	argTypes := funcDeclArgTypes(funcDecl)
	if len(argNames) != len(argTypes) {
		panic("len(argNames) != len(argTypes)")
	}
	hasContextArg := len(argTypes) > 0 && argTypes[0] == "context.Context"
	resultTypes := funcDeclResultTypes(funcDecl)

	fmt.Fprintf(w, "type %s struct{}\n\n", implType)

	fmt.Fprintf(w, "func (%s) Name() string {\n", implType)
	fmt.Fprintf(w, "\treturn \"%s\"\n", funcDecl.Name.Name)
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "func (%s) String() string {\n", implType)
	fmt.Fprintf(w, "\treturn \"%s%s\"\n", funcDecl.Name.Name, funcTypeString(funcDecl.Type))
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "func (%s) ContextArg() bool { return %t }\n", implType, hasContextArg)
	fmt.Fprintf(w, "func (%s) NumArgs()    int  { return %d }\n", implType, len(argTypes))
	fmt.Fprintf(w, "func (%s) NumResults() int  { return %d }\n\n", implType, len(resultTypes))

	fmt.Fprintf(w, "func (%s) ArgNames() []string {\n", implType)
	{
		fmt.Fprintf(w, "\treturn %#v\n", argNames)
	}
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "func (%s) ArgTypes() []reflect.Type {\n", implType)
	if len(argTypes) == 0 {
		fmt.Fprintf(w, "\treturn nil\n")
	} else {
		fmt.Fprintf(w, "\treturn []reflect.Type{\n")
		for _, t := range argTypes {
			fmt.Fprintf(w, "\t\treflect.TypeOf((*%s)(nil)).Elem(),\n", strings.Replace(t, "...", "[]", 1))
		}
		fmt.Fprintf(w, "\t}\n")
	}
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "func (%s) ResultTypes() []reflect.Type {\n", implType)
	if len(resultTypes) == 0 {
		fmt.Fprintf(w, "\treturn nil\n")
	} else {
		fmt.Fprintf(w, "\treturn []reflect.Type{\n")
		for _, t := range resultTypes {
			fmt.Fprintf(w, "\t\treflect.TypeOf((*%s)(nil)).Elem(),\n", t)
		}
		fmt.Fprintf(w, "\t}\n")
	}
	fmt.Fprintf(w, "}\n\n")

	ctxArgName := "ctx"
	if !hasContextArg {
		ctxArgName = "_"
	}
	strsArgName := "strs"
	if len(argNames) == 0 || hasContextArg && len(argNames) == 1 {
		strsArgName = "_"
	}

	fmt.Fprintf(w, "func (f %s) CallWithStrings(%s context.Context, %s ...string) (results []interface{}, err error) {\n", implType, ctxArgName, strsArgName)
	{
		for i, argName := range argNames {
			if i == 0 && hasContextArg {
				if argName != "ctx" {
					fmt.Fprintf(w, "\t%s := ctx\n", argName)
				}
				continue
			}
			strsIndex := i
			if hasContextArg {
				strsIndex--
			}
			fmt.Fprintf(w, "\tvar %s %s\n", argName, strings.Replace(argTypes[i], "...", "[]", 1))
			fmt.Fprintf(w, "\tif len(strs) > %d {\n", strsIndex)
			if argTypes[i] == "string" {
				fmt.Fprintf(w, "\t\t%s = strs[%d]\n", argName, strsIndex)
			} else {
				fmt.Fprintf(w, "\t\terr = command.AssignFromString(&%s, strs[%d])\n", argName, strsIndex)
				fmt.Fprintf(w, "\t\tif err != nil {\n")
				{
					fmt.Fprintf(w, "\t\t\treturn nil, command.NewErrArgFromString(err, f, %q)\n", argName)
				}
				fmt.Fprintf(w, "\t\t}\n")
			}
			fmt.Fprintf(w, "\t}\n")
		}

		if len(resultTypes) > 0 {
			fmt.Fprintf(w, "\tresults = make([]interface{}, %d)\n", len(resultTypes))
		}
		fmt.Fprintf(w, "\t")
		if len(resultTypes) > 0 {
			for i := range resultTypes {
				if i > 0 {
					fmt.Fprintf(w, ", ")
				}
				fmt.Fprintf(w, "results[%d]", i)
			}
			fmt.Fprintf(w, " = ")
		}
		ellipsis := ""
		if len(argTypes) > 0 && strings.HasPrefix(argTypes[len(argTypes)-1], "...") {
			ellipsis = "..."
		}
		fmt.Fprintf(w, "%s(%s%s)\n", funcDecl.Name.Name, strings.Join(argNames, ", "), ellipsis)
		fmt.Fprintf(w, "\treturn results, nil\n")
	}
	fmt.Fprintf(w, "}\n\n")

	fmt.Fprintf(w, "func (f %s) CallWithNamedStrings(%s context.Context, %s map[string]string) (results []interface{}, err error) {\n", implType, ctxArgName, strsArgName)
	{
		for i, argName := range argNames {
			if i == 0 && hasContextArg {
				if argName != "ctx" {
					fmt.Fprintf(w, "\t%s := ctx\n", argName)
				}
				continue
			}
			fmt.Fprintf(w, "\tvar %s %s\n", argName, strings.Replace(argTypes[i], "...", "[]", 1))
			fmt.Fprintf(w, "\tif str, ok := strs[%q]; ok {\n", argName)
			if argTypes[i] == "string" {
				fmt.Fprintf(w, "\t\t%s = str\n", argName)
			} else {
				fmt.Fprintf(w, "\t\terr = command.AssignFromString(&%s, str)\n", argName)
				fmt.Fprintf(w, "\t\tif err != nil {\n")
				{
					fmt.Fprintf(w, "\t\t\treturn nil, command.NewErrArgFromString(err, f, %q)\n", argName)
				}
				fmt.Fprintf(w, "\t\t}\n")
			}
			fmt.Fprintf(w, "\t}\n")
		}

		if len(resultTypes) > 0 {
			fmt.Fprintf(w, "\tresults = make([]interface{}, %d)\n", len(resultTypes))
		}
		fmt.Fprintf(w, "\t")
		if len(resultTypes) > 0 {
			for i := range resultTypes {
				if i > 0 {
					fmt.Fprintf(w, ", ")
				}
				fmt.Fprintf(w, "results[%d]", i)
			}
			fmt.Fprintf(w, " = ")
		}
		ellipsis := ""
		if len(argTypes) > 0 && strings.HasPrefix(argTypes[len(argTypes)-1], "...") {
			ellipsis = "..."
		}
		fmt.Fprintf(w, "%s(%s%s)\n", funcDecl.Name.Name, strings.Join(argNames, ", "), ellipsis)
		fmt.Fprintf(w, "\treturn results, nil\n")
	}
	fmt.Fprintf(w, "}\n\n")

	return nil
}

func GetFunctionImports(outImportLines map[string]bool, file *ast.File, funcDecl *ast.FuncDecl) error {
	funcSelectors := make(map[string]bool)
	astExprSelectors(funcDecl.Type, funcSelectors)
	// fmt.Println(funcSelectors)
	for _, imp := range file.Imports {
		if imp.Name != nil {
			if funcSelectors[imp.Name.Name] {
				delete(outImportLines, imp.Path.Value)
				outImportLines[imp.Name.Name+" "+imp.Path.Value] = true
			}
			continue
		}
		guessedName, err := guessPackageNameFromPath(imp.Path.Value)
		if err != nil {
			return err
		}
		if funcSelectors[guessedName] && !outImportLines[guessedName+" "+imp.Path.Value] {
			outImportLines[imp.Path.Value] = true
		}
	}
	return nil
}

func guessPackageNameFromPath(path string) (string, error) {
	pkg := path
	if len(pkg) >= 2 && pkg[0] == '"' && pkg[len(pkg)-1] == '"' {
		pkg = pkg[1 : len(pkg)-1]
	}
	pkg = pkg[strings.LastIndex(pkg, "/")+1:]
	pkg = strings.TrimPrefix(pkg, "go-")
	pkg = strings.TrimSuffix(pkg, ".go")
	if pkg == "" || strings.ContainsAny(pkg, ".-") {
		return "", fmt.Errorf("could not guess package name from import path %s", path)
	}
	return pkg, nil
}

func funcDeclArgNames(funcDecl *ast.FuncDecl) (names []string) {
	for _, field := range funcDecl.Type.Params.List {
		for _, name := range field.Names {
			names = append(names, name.Name)
		}
	}
	return names
}

func funcDeclArgTypes(funcDecl *ast.FuncDecl) (types []string) {
	for _, field := range funcDecl.Type.Params.List {
		for range field.Names {
			types = append(types, astExprString(field.Type))
		}
	}
	return types
}

func funcDeclResultTypes(funcDecl *ast.FuncDecl) (types []string) {
	for _, field := range funcDecl.Type.Results.List {
		types = append(types, astExprString(field.Type))
		for i := 1; i < len(field.Names); i++ {
			types = append(types, astExprString(field.Type))
		}
	}
	return types
}

func funcTypeString(functype *ast.FuncType) string {
	var b strings.Builder
	b.WriteByte('(')
	for fieldIndex, field := range functype.Params.List {
		if fieldIndex > 0 {
			b.WriteString(", ")
		}
		for i, name := range field.Names {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(name.Name)
		}
		b.WriteByte(' ')
		b.WriteString(astExprString(field.Type))
	}
	b.WriteByte(')')
	if len(functype.Results.List) == 0 {
		return b.String()
	}
	b.WriteByte(' ')
	if len(functype.Results.List) == 1 && len(functype.Results.List[0].Names) == 0 {
		b.WriteString(astExprString(functype.Results.List[0].Type))
		return b.String()
	}
	b.WriteByte('(')
	for fieldIndex, field := range functype.Results.List {
		if fieldIndex > 0 {
			b.WriteString(", ")
		}
		for i, name := range field.Names {
			if i > 0 {
				b.WriteString(", ")
			}
			b.WriteString(name.Name)
		}
		b.WriteByte(' ')
		b.WriteString(astExprString(field.Type))
	}
	b.WriteByte(')')
	return b.String()
}

func astExprString(expr ast.Expr) string {
	switch e := expr.(type) {
	case nil:
		return ""
	case *ast.Ident:
		return e.Name
	case *ast.SelectorExpr:
		return astExprString(e.X) + "." + e.Sel.Name
	case *ast.StarExpr:
		return "*" + astExprString(e.X)
	case *ast.Ellipsis:
		return "..." + astExprString(e.Elt)
	case *ast.ArrayType:
		return "[" + astExprString(e.Len) + "]" + astExprString(e.Elt)
	case *ast.MapType:
		return "map[" + astExprString(e.Key) + "]" + astExprString(e.Value)
	case *ast.FuncType:
		return "func" + funcTypeString(e)
	default:
		panic(fmt.Sprintf("UNKNOWN: %#v", expr))
	}
}

func astExprSelectors(expr ast.Expr, selectors map[string]bool) {
	switch e := expr.(type) {
	case *ast.Ident:
		// Name without selector
	case *ast.SelectorExpr:
		selectors[e.X.(*ast.Ident).Name] = true
	case *ast.StarExpr:
		astExprSelectors(e.X, selectors)
	case *ast.Ellipsis:
		astExprSelectors(e.Elt, selectors)
	case *ast.ArrayType:
		astExprSelectors(e.Elt, selectors)
	case *ast.StructType:
		for _, f := range e.Fields.List {
			astExprSelectors(f.Type, selectors)
		}
	case *ast.CompositeLit:
		for _, elt := range e.Elts {
			astExprSelectors(elt, selectors)
		}
	case *ast.MapType:
		astExprSelectors(e.Key, selectors)
		astExprSelectors(e.Value, selectors)
	case *ast.ChanType:
		astExprSelectors(e.Value, selectors)
	case *ast.FuncType:
		for _, p := range e.Params.List {
			astExprSelectors(p.Type, selectors)
		}
		for _, r := range e.Results.List {
			astExprSelectors(r.Type, selectors)
		}
	default:
		panic(fmt.Sprintf("UNSUPPORTED: %#v", expr))
	}
}

func filterGoFiles(excludeFilenames ...string) func(info os.FileInfo) bool {
	return func(info os.FileInfo) bool {
		if info.IsDir() {
			return false
		}
		name := info.Name()
		for _, exclude := range excludeFilenames {
			if name == exclude {
				return false
			}
		}
		if filepath.Ext(name) != ".go" {
			return false
		}
		if strings.HasSuffix(name, "_test.go") {
			return false
		}
		return true
	}
}
