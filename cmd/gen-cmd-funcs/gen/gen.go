package gen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"github.com/ungerik/go-astvisit"
	"golang.org/x/tools/imports"
)

func PackageFunctions(pkgDir, genFilename, namePrefix string, printOnly bool, onlyFuncs ...string) error {
	pkgName, funcs, err := parsePackage(pkgDir, genFilename, onlyFuncs...)
	if err != nil {
		return err
	}

	importLines := map[string]bool{
		`"reflect"`: true,
		`command "github.com/ungerik/go-command"`: true,
	}
	for _, fun := range funcs {
		err = GetFunctionImports(importLines, fun.File, fun.Decl)
		if err != nil {
			return err
		}
	}
	var sortedImportLines []string
	for l := range importLines {
		sortedImportLines = append(sortedImportLines, l)
	}
	sort.Strings(sortedImportLines)

	b := bytes.NewBuffer(nil)

	fmt.Fprintf(b, "// This file has been AUTOGENERATED!\n\n")
	fmt.Fprintf(b, "package %s\n\n", pkgName)
	if len(sortedImportLines) > 0 {
		fmt.Fprintf(b, "import (\n")
		for _, importLine := range sortedImportLines {
			fmt.Fprintf(b, "\t%s\n", importLine)
		}
		fmt.Fprintf(b, ")\n\n")
	}

	for funName, fun := range funcs {
		err = WriteFunctionImpl(b, fun.File, fun.Decl, namePrefix+funName, "")
		if err != nil {
			return err
		}
	}

	genFileData := b.Bytes()
	genFilePath := filepath.Join(pkgDir, genFilename)

	imports.LocalPrefix = "github.com/ungerik/"
	genFileData, err = imports.Process(genFilePath, genFileData, &imports.Options{Comments: true, FormatOnly: true})
	if err != nil {
		return err
	}

	if printOnly {
		fmt.Println(genFileData)
	} else {
		fmt.Println("Writing file", genFilePath)
		err = ioutil.WriteFile(genFilePath, genFileData, 0660)
		if err != nil {
			return err
		}
	}
	// err = exec.Command("gofmt", "-s", "-w", genFile).Run()
	// if err != nil {
	// 	return err
	// }

	return nil
}

func RewriteGenerateFunctionTODOs(filePath string, printOnly bool) (err error) {
	fileDir := filepath.Dir(filePath)
	fileData, err := ioutil.ReadFile(filePath)
	if err != nil {
		return err
	}
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, fileData, parser.DeclarationErrors)
	if err != nil {
		return err
	}

	imports := make(map[string]string)
	for _, imp := range file.Imports {
		var pkgName string
		if imp.Name != nil {
			pkgName = imp.Name.Name
		} else {
			pkgName, err = guessPackageNameFromPath(imp.Path.Value)
			if err != nil {
				return err
			}
		}
		pkgPath, err := strconv.Unquote(imp.Path.Value)
		if err != nil {
			return err
		}
		imports[pkgName] = pkgPath
	}

	importFuncs := make(map[string]map[string]funcInfo)
	for pkgName, pkgImportPath := range imports {
		loc, err := astvisit.LocatePackage(fileDir, pkgImportPath)
		if err != nil {
			return err
		}
		if loc.Std {
			continue
		}
		_, funcs, err := parsePackage(loc.SourcePath, "")
		if err != nil {
			return err
		}
		importFuncs[pkgName] = funcs
	}

	buf := bytes.NewBuffer(nil)
	nextSourceOffset := 0
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.VAR {
			continue
		}
		if len(genDecl.Specs) != 1 {
			continue
		}
		// ast.Print(fileSet, decl)
		valueSpec, ok := genDecl.Specs[0].(*ast.ValueSpec)
		if !ok || len(valueSpec.Names) != 1 || len(valueSpec.Values) != 1 {
			continue
		}
		implName := valueSpec.Names[0].Name
		callExpr, ok := valueSpec.Values[0].(*ast.CallExpr)
		if !ok || len(callExpr.Args) != 1 || astvisit.ExprString(callExpr.Fun) != "command.GenerateFunctionTODO" {
			continue
		}
		sel, ok := callExpr.Args[0].(*ast.SelectorExpr)
		if !ok {
			continue
		}
		pkgName := astvisit.ExprString(sel.X)
		funcName := astvisit.ExprString(sel.Sel)
		pkgFuncs, ok := importFuncs[pkgName]
		if !ok {
			continue
		}
		fun, ok := pkgFuncs[funcName]
		if !ok {
			continue
		}
		// Found a function to replace the placeholder variable,
		// write all unwritten source bytes until variable declaraton
		endOffset := fset.Position(decl.Pos()).Offset
		buf.Write(fileData[nextSourceOffset:endOffset])
		nextSourceOffset = fset.Position(decl.End()).Offset

		fmt.Fprintf(buf, "////////////////////////////////////////\n")
		fmt.Fprintf(buf, "// %s.%s\n\n", pkgName, fun.Decl.Name.Name)
		fmt.Fprintf(buf, "// %s wraps %s.%s as command.Function (generated code)\n", implName, pkgName, fun.Decl.Name.Name)
		fmt.Fprintf(buf, "var %[1]s %[1]sT\n\n", implName)
		err = WriteFunctionImpl(buf, fun.File, fun.Decl, implName+"T", pkgName)
		if err != nil {
			return err
		}

		// format.Node(buf)
	}
	// Write unwritten rest of original source bytes
	buf.Write(fileData[nextSourceOffset:])

	if printOnly {
		fmt.Println(buf.String())
	} else {
		fmt.Println("Writing file", filePath)
		err = ioutil.WriteFile(filePath, buf.Bytes(), 0660)
		if err != nil {
			return err
		}
	}
	return nil
}

type funcImpl struct {
	VarName     string
	CallFunc    string
	Type        string
	DeclIndices []int
}

func findFuncImpls(file *ast.File) []*funcImpl {
	ordered := make([]*funcImpl, 0)
	named := make(map[string]*funcImpl)
	typed := make(map[string]*funcImpl)

	for i, decl := range file.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			if len(d.Specs) != 1 {
				continue
			}
			valueSpec, ok := d.Specs[0].(*ast.ValueSpec)
			if !ok || len(valueSpec.Names) != 1 {
				continue
			}
			switch d.Tok {
			case token.VAR:
				implVarName := valueSpec.Names[0].Name

				if len(valueSpec.Values) == 0 {
					// Example:
					//   // documentCanUserRead wraps document.CanUserRead as command.Function
					//   var documentCanUserRead documentCanUserReadT
					comment := valueSpec.Comment.Text()
					prefix := implVarName + " wraps "
					suffix := " as command.Function"
					if !strings.HasPrefix(comment, prefix) || !strings.HasSuffix(comment, suffix) {
						continue
					}
					callFunc := comment[len(prefix) : len(comment)-len(suffix)]
					impl := named[implVarName]
					if impl == nil {
						impl = new(funcImpl)
						ordered = append(ordered, impl)
						named[implVarName] = impl
					}
					impl.VarName = implVarName
					impl.CallFunc = callFunc
					impl.DeclIndices = append(impl.DeclIndices, i)
					impl.Type = astvisit.ExprString(valueSpec.Type)
					typed[impl.Type] = impl
					continue
				}

				if len(valueSpec.Values) != 1 {
					continue
				}
				callExpr, ok := valueSpec.Values[0].(*ast.CallExpr)
				if !ok || len(callExpr.Args) != 1 || astvisit.ExprString(callExpr.Fun) != "command.GenerateFunctionTODO" {
					continue
				}
				impl := named[implVarName]
				if impl == nil {
					impl = new(funcImpl)
					ordered = append(ordered, impl)
					named[implVarName] = impl
				}
				impl.VarName = implVarName
				impl.CallFunc = astvisit.ExprString(callExpr.Args[0])
				impl.DeclIndices = append(impl.DeclIndices, i)

			case token.TYPE:
				if len(valueSpec.Values) != 1 || astvisit.ExprString(valueSpec.Values[0]) != "struct{}" {
					continue
				}
				implTypeName := valueSpec.Names[0].Name
				// Example:
				//   // documentCanUserReadT wraps document.CanUserRead as command.Function
				//   type documentCanUserReadT struct{}
				comment := valueSpec.Comment.Text()
				prefix := implTypeName + " wraps "
				suffix := " as command.Function"
				if !strings.HasPrefix(comment, prefix) || !strings.HasSuffix(comment, suffix) {
					continue
				}
				callFunc := comment[len(prefix) : len(comment)-len(suffix)]
				impl := typed[implTypeName]
				if impl == nil {
					impl = new(funcImpl)
					ordered = append(ordered, impl)
					typed[implTypeName] = impl
					impl.Type = implTypeName
					// No var with that type declared
					// so also use the type like a var
					// and let the user instanciate the type with {}
					named[implTypeName] = impl
					impl.VarName = implTypeName
				}
				impl.CallFunc = callFunc
				impl.DeclIndices = append(impl.DeclIndices, i)
			}

		case *ast.FuncDecl:
			if d.Recv.NumFields() != 1 {
				continue
			}
			recvType := astvisit.ExprString(d.Recv.List[0].Type)
			impl := typed[recvType]
			if impl == nil {
				continue
			}
			impl.DeclIndices = append(impl.DeclIndices, i)
		}
	}

	return ordered
}
